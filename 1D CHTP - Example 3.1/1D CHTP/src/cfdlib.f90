module cfdlib
	use user
	implicit none


contains

!-----------------------------------------------------------------------------------------------!
!-----------------------------------------------------------------------------------------------!
!					start (T)						!
!-----------------------------------------------------------------------------------------------!
!-----------------------------------------------------------------------------------------------!

subroutine start (T,Ti,Tref)

	implicit none
	integer:: i
	real(KIND = DP)  :: Tref
	real(KIND = DP), dimension(Nx) :: T,Ti

	Tref=(Ta+Tb)/2.0D+00

	T(1)=0
	T(7)=100

	Ti(1)=0
	Ti(7)=100

	Do i=2,Nx-1
		
		Ti(i)=Tref
	
	end do

    return
end subroutine start

!-----------------------------------------------------------------------------------------------!
!-----------------------------------------------------------------------------------------------!
!						coef_T 					    !
!-----------------------------------------------------------------------------------------------!
!-----------------------------------------------------------------------------------------------!
!-----------------------------------------------------------------------------------------------!

subroutine COEF_T(DXP,DX,X,			&
	         ap,ae,aw,b)

	implicit none

	integer:: i

	real(KIND = DP)  :: 			&
		G,DX	

	real(KIND = DP), dimension(Nx) :: 	&
		DXP,X

	real(KIND = DP), dimension(Nx) :: 	&
		ae,aw,ap,b

!-----------------------------------------------------------------------------------------------!
!					varaibles reset					    !
!-----------------------------------------------------------------------------------------------!


		do i=1,Nx

			ae(i)=0.0D+00

			aw(i)=0.0D+00

			ap(i)=0.0D+00

			b(i)=0.0D+00

		end do


		do  i=2,Nx-1

!-----------------------------------------------------------------------------------------------!
!					COEFICIENT DETERMINATION				    !
!-----------------------------------------------------------------------------------------------!

!	 Calculo da gamma
	G=Lambda/Cp
	

	ae(i)=G/DXP(I+1)

	aw(i)=G/DXP(I)

     	ap(i)=ae(i)+aw(i)

      	b(i)=0

		end do

!-----------------------------------------------------------------------------------------------!
!					BOUNDARY CONDITIONS					!
!-----------------------------------------------------------------------------------------------!


!					WEST					!

		ae(1)=0.0D+00
		aw(1)=0.0D+00
		ap(1)=1.0D+00
		b(1)=Ta

!					EAST					!
		ae(Nx)=0.0D+00
		aw(Nx)=0.0D+00
		ap(Nx)=1.0D+00
		b(Nx)=Tb
	
end Subroutine coef_T

!-----------------------------------------------------------------------------------------------!
!-----------------------------------------------------------------------------------------------!
!						converegence					!
!-----------------------------------------------------------------------------------------------!
!-----------------------------------------------------------------------------------------------!

function converegence(Res_T,iter)


	real(KIND = DP):: Res_T,Rmax
	logical:: converegence
	integer:: iter

	Rmax = Res_T
	if (Rmax .gt. 1.0D+20) stop 'A friendly message: diverged'

	converegence=(Res_T.LE.epsilonT)

	return
end

!-----------------------------------------------------------------------------------------------!
!					RESIDUAL						!
!-----------------------------------------------------------------------------------------------!

subroutine residual(T,ap,ae,aw,b,Res_T,Rmax_T)

	real(KIND = DP)  :: 			&
		RES_T,resi,summ,Rmax_T

	real(KIND = DP), dimension(Nx) :: 	&
		ae,aw,ap,b
	
	real(KIND = DP), dimension(Nx) :: T

	summ=0.0D+00
	Rmax_T=0.0D+00

	do i=2,Nx-1

		Resi=dabs(ap(i)*T(i)-ae(i)*T(i+1)-aw(i)*T(i-1)-b(i))
		summ=summ+(Resi*Resi)

		if (Resi .gt. Rmax_T) Rmax_T=Resi

		end do

	Res_T=dsqrt(summ)

	return	
end subroutine residual

end module cfdlib
